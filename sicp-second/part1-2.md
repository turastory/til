# Building Abstraction with Procedures (continued )

## 1.2 Procedures and the Processes They Generate

In the previous section, we've discussed about the elements of the programming and leaned the rules for making programs.

But we don't know the strategy for making programs - which procedure is useful in which circumstance, and the consequences of those procedures.

Even it's relatively cheap to fix or make a change to the existing programs, compared to other domains like architecture, photography, to visualize the process of the procedures we make, is crucial to build relible programs.

##### Evolution of a process

> A procedure is a *pattern* for the **local evolution** of a computational process. It specifies how each stage of the process is built upon the previous stage.

As we've seen in section 1.1, A computational process is not a real thing but rather an abstract thing, and is *directed by* a pattern of rules, called **program**.

**The word "evolution" means "development in a gradual manner".** Executing each procedure makes the process *evlove*, and these procedures together define the overall behavior of a process.

##### Shape of a process

> In this section we will examine some common "**shapes**" for processes generated by simple procedures.

**"shape" in this statement stands for "the way a process move, generated by a procedure"**.



### 1.2.1 Linear Recursion and Iteration

##### Linear Recursion Process

Here's a simple procedure to calculate factorial.

```scheme
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
```

Executing this procedure would generate the following shape:

```scheme
(factorial 5)
(* 5 (factorial 4))
(* 5 (* 4 (factorial 3)))
(* 5 (* 4 (* 3 (factorial 2))))
(* 5 (* 4 (* 3 (* 2 (factorial 1)))))
(* 5 (* 4 (* 3 (* 2 1))))
(* 5 (* 4 (* 3 2)))
(* 5 (* 4 6))
(* 5 24)
120
```

As you can see, executing `factorial` procedure draws a curved, convex shape. This kind of process is called **recursive process**. The `factorial` procedure generates a linear recursive process.

Recursive process - "expansion followed by contraction"

- The expansion occurs at the process builds up a chain of *deferred oprations*.
- The contraction occurs as the operations are actually performed.

In this case, the interpreter should remember deferred operations, and the amount of information grows linearly with `n`.

##### Linear Iterative Process

We may take another approach. Here's an alternative:

```scheme
(define (fact-iter sum count n)
  (fact-iter (* sum count) (+ count 1) n))
```

This procedure generates the following shape:

```scheme
(fact-iter 6)
(iter 1 1 6)
(iter 1 2 6)
(iter 2 3 6)
(iter 6 4 6)
(iter 24 5 6)
(iter 120 6 6)
(iter 720 7 6)
720
```

As you can see, executing `fact-iter` procedure draws a flat shape. This kind of process is called **iterative process**.

> In general, an iterative process is one whose **state can be summarized**
> **by a fixed number of state variables**, together with a fixed rule
> that describes **how the state variables should be updated as the process
> moves from state to state** and an (optional) end test that specifies **conditions
> under which the process should terminate**.

So in iterative process, each step can be captured as states, and the procedure describes how these states move from one to another.

This notion is interesting, since if we stop the process in the middle of the steps, then later we can resume the process from in which we left.

In this case, the number of steps required to compute, grows linearly with `n`.

##### Procedure vs Process, tail-recursive

You may notice that `iter` procedure in `fact-iter` procedure, is really a recursive procedure. But even if the syntatic form of the procedure is recursive, the generating process is iterative.

> In common programming languages like C, are designed in such a way that the interpretation of any recursive procedure consumes an amount of memory, that grows with the number of procedure calls, even when the process described is iterative.

In languages like C, the only way to describe iterative process is using looping constructs. On the other hand, some languages like Scala or LISP supports **tail-recursive** property.

With tail-recursive property, iteration can be expressed using the ordinary procedures - looping constructs are just syntatic sugar.



### 1.2.2 Tree Recursion

Here's a procedure for computing fibonacci numbers:

```scheme
(define (fibo n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fibo (- n 1)) (fibo (- n 2))))))
```

This procedure evalautes like this:

```scheme
(fibo 5)
(+ (fibo 4) (fibo 3))
(+ (+ (fibo 3) (fibo 2)) (+ (fibo 2) (fibo 1)))
...
```

Notice the branches split into two at each step. This procedure generates a **tree-recursive process**. As you can see, the number of steps required grows *exponentially* with the given input value, while the amount of information whom the interpreter should remember is proportional to the maximum depth of the tree.

Here's an iterative approach to fibonacci numbers:

```scheme
(define (fibo-iter n)
  (define (iter a b count)
    (if (> count 0)
        (iter (+ a b) a (- count 1))
        b))
  (iter 1 0 n))
```

This procedure generates an iterative process, and it's much more efficient way to calculate fibonacci numbers than the former one.

It may seem recursive process is useless, but that's not true.

- Tree-recursive process is natural and powerful tool for dealing with symbolic/hierarchical data. Indeed, the interpreter evaluates expression using tree-recursive process.
- Generally it is more straightforward than iterative process and one can use it as a guide to understand, or design programs.



### Exercises

##### Exercise 1.9

The first procedure evaluates like this:

```scheme
(define (+ a b)
  (if (= a 0) b (inc (+ (dec a) b))))

(+ 4 5)
(inc (+ (dec 4) 5))
(inc (+ 3 5))
```

At this point, we can figure out that this procedure generates a **recursive process**. In order to apply the procedure `inc`, we first need to evaluate its argument - `(+ 3 5)`.

The second procedure evaluates like this:

```scheme
(define (+ a b)
  (if (= a 0) b (+ (dec a) (inc b))))

(+ 4 5)
(+ (dec a) (inc b))
(+ 3 6)
```

Just like the first procedure, we know that this procedure generates a **iterative process**. You can see the shape of the last line is same as the first line.

